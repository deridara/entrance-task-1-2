# test_task

* После просмотра ошибок в консоли почитала руководство к webpack

* По ошибком проверила импорт функции initMap, увидела, что экспорт по умолчанию реализован как обычный экспорт, добавила нужный export default. Возможно, изначально использовался просто экспорт, затем был заменен на экспорт по умолчанию в файле index.js, но не исправлен в файле map.js.

* Посмотрела index.html через Chrome dev tools, увидела 'height: 0' у блока maps, прописала размеры окна в стилях. После этого начала отображаться карта, но без станций. 

* Посмотрела, как выглядят получаемые данные о станции и как они интерпретируются, заметила, что координаты не соответствуют Москве, исправила порядок присваевымых в mapper.js широты и долготы. Наверное, это одно из самых очевидных мест, куда я бы добавляла баги, если бы у меня была такая цель.

* Изучила руководство yandex maps API, вставила пропущенный вызов myMap.geoObjects.add(objectManager) для отображения элементов на карте, станции стали отображаться и собираться в кластеры. Возможно, эта важная строка была удалена случайно вместе с другим куском кода.

* Проверила, отображаются ли красным цветом нерабочие станции, это работало без ошибок.

* Методом пристального вглядывания был обнаружен незакрытый тег div в шаблоне содержимого балуна. Затем в консоли браузера применила этот шаблон к тестовому объекту, получила html и прогнала его через валидатор, который обнаружил ошибку в закрытии тега canvas. В браузере Chrome и Firefox данные ошибки не критичны, все отображается несмотря на них.

* Не работает макет балуна. Изучила документацию, узнала, что значение ключа build наследуется от родительского класса. Выяснила, что если вообще не задавать значения overrides build и clear, то на наследуемых значениях балун с нужным макетом внутри отображается. Если задавать build с наследованием this.constructor.superclass.build.call(this); балун уже не отображается, даже если скопировать из родительского класса функцию и вставить в build.

* Стало ясно, что this в функции build имеет значение undefined до вызова конструктора superclass, а его вызов зависает. Так как стрелочные функции не имеют собственного this, поменяла их синтаксис на function(). После этого методы build и clear стали работать. Поискала информацию, теперь знаю, что стрелочные функции в принципе нельзя использовать как методы объекта. Ошибка могла возникнуть из-за того, что программист привык использовать стрелочные функции везде, где нужны анонимные функции, и не учел их особенности.

* Во время изученя документации по кластерами нашла опцию pieChart, заменила аргументы objectManager.clusters.options.set. Затем обнаружила, что при создании ObjectManager отображение кластеров по умолчанию и так pieChart, но они перезаписываются далее вызовом objectManager.clusters.options.set. Возможно, в какой-то момент поменялось ТЗ, и программисту пришлось не глядя на уже заданные значения переписывать параметры кластеров.